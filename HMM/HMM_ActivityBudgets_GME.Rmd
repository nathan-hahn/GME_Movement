---
title: "Activity Moving Windows"
author: "Nathan Hahn"
date: "6/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(xts)
library(zoo)
theme_set(  theme_bw() + # set theme with no legend of strip text
              theme(panel.grid.major = element_blank(),
                    strip.background = element_blank(),
                    panel.border = element_rect(colour = "black"),
                    strip.text = element_text(size = 12),
                    legend.text = element_text(size = 10),
                    panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), axis.title=element_text(size=14), axis.text = element_text(size=12))
)

# load functions
source("../GME_functions.R")
```

### Prep Data

Add viterbi estimates to the original data (pretransformation of step lengths and covariates)
```{r cars}
##### Prep Data #####
hmm.df <- readRDS("../HMM/model results/TEST_m2_indiv_df.rds") # output from hmm model (no squared term)
output <- readRDS("../HMM/model results/TEST_traindf_original.rds") # dataset prior to data transforms

# add viterbi estimates to the original dataframe -- revert to non-standardized covs and steps
output$viterbi <- hmm.df$viterbi
# create new varibles to differentiate ag and non-ag in non-protected areas
output$ag.used <- ifelse(output$lc.estes == 1, 1, 0)
output$pa <- factor(output$pa, levels = c(3:1))
output$pa.2 <- ifelse(output$pa == 1 & output$ag.used == 1, 4, output$pa)

# format covariates for plotting
output <- mutate(output, viterbi = recode_factor(viterbi, 
                                                 "1" = "encamped",
                                                 "2" = "foraging",
                                                 "3" = "transit"),
                 pa.2 = recode_factor(pa.2, "1" = "protected", "2" = "limited use", 
                                      "3" = "not protected", "4" = "ag")
) 

```

```{r, warning=FALSE}
###### Identify Ag Use Windows #####

split <- split(output, output$burst)
window <- c(13,25,49, 73) # in hours. Split to before and after when align = center

output.plot <- NULL
for(i in 1:length(window)){
  # calculate moving window stats - see rollstats function
  output.plot[[i]] <- window_stats(df.list = split, window = window[[i]])
  # remove NAs from ag windows - created by window cutoff
  output.plot[[i]] <- filter(output.plot[[i]], is.na(ag.window) == FALSE) %>% droplevels()
}

```

### Activty Budgets

The three plots below show comparisons of activity budgets of 5 elephants when they are in non-ag (0) and in an ag matrix (1). The window sizes are incrementally increased to inspect the sensitivity of the activity budgets to the choice of window size. They appear highly sensitive, where larger windows smooth over differences. This is likely due to elephants quickly returning to normal activity when not raiding. 

A fourth graph is included of activity by land-use type for comparison. The differences are much clearer using the window approach. 

```{r}
##### Activity Budgets #####

# budgets by ag window
x.12 <- plot_budget(t = output.plot[[1]], facet = viterbi ~ ag.window, title = "GME: Activity budget with 12 hour window")
x.12

x.24 <- plot_budget(t = output.plot[[2]], facet = viterbi ~ ag.window, title = "GME: Activity budget with 24 hour window")
x.24

x.48 <- plot_budget(t = output.plot[[3]], facet = viterbi ~ ag.window, title = "GME: Activity budget with 48 hour window")
x.48

x.72 <- plot_budget(t = output.plot[[4]], facet = viterbi ~ ag.window, title = "GME: Activity budget with 72 hour window")
x.72

# budget by land use
# landUse <- plot_budget(t = output.plot[[1]], facet = viterbi ~ pa.2, title = "GME: Activity budget by land use type")
# landUse
```


```{r}
ggplot(output.plot[[2]], aes(hour(date))) + facet_grid(~viterbi) + stat_ecdf(aes(colour = ag.window), geom = "step") 

ecdf <- NULL
split <- split(output.plot[[2]], list(output.plot[[2]]$ag.window, 
                                      output.plot[[2]]$viterbi))
for (i in 1:length(split)){
  ecdf[[i]] <- ecdf(hour(split[[i]]$date))
  #ks[[i]] <- ks.test(ecdf[[i]])
}

```







### Overlap test

Initial overlap test compares the distributions in and outside of the ag matrix, across the three activity states.

A von Mises PDF is constructed because the activity distribution is circular (24 hour time). 

Overlap test uses bootstrapping to construct confidence intervals and test for significant differences between the two distributions. 


```{r}
library(overlap)
overlap <- output.plot[[2]] # 24 hour window
## convert time to radians

# convert time to minutes elapsed in the day (circular time distribution) - divide by 1440 to put time on 0-1 scale
day.minutes <- ((hour(overlap$date) + minute(overlap$date)/60)*60)/1440
timeRad <- day.minutes * 2 * pi

# seperate data into buckets for testing
encamped.0 <- timeRad[which(overlap$viterbi == "encamped" | overlap$ag.window == 0)]
encamped.1 <- timeRad[which(overlap$viterbi == "encamped" | overlap$ag.window == 1)]
forage.0 <- timeRad[which(overlap$viterbi == "foraging" | overlap$ag.window == 0)]
forage.1 <- timeRad[which(overlap$viterbi == "foraging" | overlap$ag.window == 1)]
transit.0 <- timeRad[which(overlap$viterbi == "transit" | overlap$ag.window == 0)]
transit.1 <- timeRad[which(overlap$viterbi == "transit" | overlap$ag.window == 1)]


densityPlot(encamped.0, kmax = 3)

# overlap tests
encamped_est <- overlapEst(encamped.0, encamped.1, type = "Dhat4")
forage_est <- overlapEst(forage.0, forage.1, type="Dhat1")
transit_est <- overlapEst(transit.0, transit.1, type ="Dhat1")

# Bootstraping
encamped.boot <- bootstrap(encamped.0, encamped.1, 1000, type = "Dhat4")

# CI
bootCI(encamped_est, encamped.boot)
```

