##### Individual-Level SSF #####

library(amt)
library(tidyverse)
library(sjPlot)
library(terra)
library(sf)
library(tictoc)
library(parallel)

set.seed(1)

##### 1a. Prepare Data #####

# read data
#movdata <- readRDS('./SSF/eledata_expanded.rds')

movdata <- readRDS('./SSF/eledata_allmara.RDS')
movdata <- movdata[!movdata$subject_name %in% c('Shamba','Courtney','David','Pepper', 'Bobo'),]
movdata <- movdata[movdata$fixType != 'irregular',]
movdata$uid <- 1:nrow(movdata)

# create date object
movdata$date <- as.POSIXct(movdata$date) # check still in EAT

# add new variable for individual-year (name-year) that can be used to group and fit models by. Years use april cutoff
movdata$subject_year <- paste(movdata$subject_name, movdata$year.cuts, sep = '-')

# make a move object for the amt package - we will use the id, which is a
#         combination of the animal's name and collar number
track <- make_track(movdata, .x = x, .y = y, .t = date, subject_name = subject_name, subject_year = subject_year, subject_sex = subject_sex, tactic.season = tactic.season, uid = uid)
t1 <- split(track, track$subject_name) # subject_name or subject_year

# create bursts and traj - map the two functions to a nested dataset t1
t2 <- lapply(t1, function(x)
  x %>% track_resample(rate = minutes(60), tolerance = minutes(30)) %>% steps_by_burst(keep_cols='end'))


## plot the step length and turning angle distributions

# Plot step length and turn angle distributions
p <- do.call(rbind, t2)
ggplot(p, aes(sl_, fill = factor(subject_year))) + geom_density(alpha = 0.4)
ggplot(p, aes(ta_, fill = factor(subject_year))) + geom_density(alpha = 0.4)

max(p$sl_) # 13k

# t2 <- lapply(t2, function(x)
#   x %>% filter(sl_ < 9000)) #(~9km/hr max)

p %>% group_by(subject_year) %>% tally()

##### Generate SSF Availability sample #####
#' Next we will generate the availability sample for the Step Selection and integrated Step Selection functions. 
#' Here, the availability sample is generated by drawing random steps that the animal could have taken from each recorded
#' location. We draw 5 steps per used location, and  assume a gamma step length distribution and von Mises 
#' turning angle distribution. 

## make random steps for SSF and iSSF

avail.steps = 10
# get pop-level step length and turn angle distributions
p <- do.call(rbind, t2)
sl_distr = fit_distr(p$sl_, "gamma")
ta_distr = fit_distr(p$ta_, "vonmises")

# create random steps ~ xx seconds for allmara dataset!!
{tic()
  cores = 6
  ssf.randsteps <- parallel::mclapply(t2, function(x) {
    set.seed(1)
    x %>% random_steps(n_control = avail.steps, 
                      sl_distr = sl_distr,
                      ta_distr = ta_distr) }, mc.cores = cores)
toc()}

# create dataframe
ssf.df <- do.call(rbind, ssf.randsteps)
# check
dim(ssf.df)
head(ssf.df)
prop.table(table(ssf.df$case_, ssf.df$subject_name), margin = 2)

# look at turning angle distribution for random steps
ssf.df %>% 
  #tidyr::unnest(col = steps) %>% # only needed if rand steps are by indv.
  filter(case_ == FALSE) %>%
  ggplot(aes(ta_, fill = factor(subject_name))) + geom_density(alpha = 0.4)

# look at step length distribution for random steps
ssf.df %>% 
  #tidyr::unnest(col = steps) %>% # only needed if rand steps are by indv.
  filter(case_ == FALSE) %>%
  ggplot(aes(sl_, fill = factor(subject_name))) + geom_density(alpha = 0.4)


prop.table(table(ssf.df$case_, ssf.df$subject_name), margin = 2)

# remove extra dataframes
remove(ssf.randsteps)

##### Covariate Extraction #####

#' We now have used (case_ == TRUE) and available (case_ == FALSE) points for each individual. Before we can begin 
#' modeling, we have to extract covariates. We will use the amt package function to do this. 

# import layers - note that to use the amt functions they need to be raster objects, not terra objects
library(terra)
# import layers
prop.ag <- rast("./spatial data/Estes_ag_pct_1500.tif")	
prop.forest <- rast("./spatial data/hansen_forest_pct_250.tif")		
slope <- rast('./spatial data/slope_estes_32736_2020-05-12.tif')
ndviCoV <- rast('./spatial data/NDVICoV_estes_32736-2022-02-03.tif')
prop.settlement.250 <- rast("spatial data/estes_settlement_pct_250.tif")
prop.settlement.1500 <- rast("spatial data/estes_settlement_pct_1500.tif")
gHM <- rast("./spatial data/gHM_estes_32736_2020-05-12.tif")

# tiedman layer
# 1 = ag
# 2 = cover20
# 3 = cover2070
# 4 = cover70
# 5 = degraded
lc <- rast("./spatial data/Tiedman/sentinel2018-3yr-GSE-02-2022_32736_agmask.tif") #SME - temp
ag <- terra::clamp(lc, lower = 1, upper = 1, values = FALSE)
cover20 <- terra::clamp(lc, lower = 2, upper = 2, values = FALSE)
cover2070 <- terra::clamp(lc, lower = 3, upper = 3, values = FALSE)
cover70 <- terra::clamp(lc, lower = 4, upper = 4, values = FALSE)

#drains
# get shapefile for drains buffer
drains <- st_read("./spatial data/drains/drains_estes_20211117/drains_estes_-2021-11-17.shp", 
                  layer="drains_estes_-2021-11-17", crs = 4326) %>%
  st_transform(crs = 32736) %>%
  filter(RIV_ORD <= 7)
# buffer by 250m
drains <- st_buffer(drains, dist = 250) %>%
  st_union() %>%
  terra::vect() %>%
  terra::rasterize(.,ag) # rasterize at 10m sentinel 


## Create covariate list
# rasters must be in a list for mcapply
r.list <- list(slope, ndviCoV, ag, cover20, cover2070, cover70, drains, prop.settlement.250, prop.settlement.1500, gHM)

## Extract

# create terra vect object
study.area <- 32736
ssf.sf <- ssf.df %>%
  ungroup() %>% select('x2_','y2_','uid') %>% # reduce number of columns to speed up vect() creation
  st_as_sf(coords = c('x2_','y2_'), crs = study.area) %>% # specify here to extract at beginning (x1/y1) or end (x2/y2) of step
  terra::vect() 

# extract in parallel - 1734 seconds with allmara dataset and 10 randpoints
{tic()
  cores = 6
  extract <- mclapply(r.list, function(x)
    terra::extract(x, ssf.sf)[,2], mc.cores = cores)
  used <- do.call(cbind, extract) # bind results into an extracted dataframe
  toc()}

# check
head(used)
summary(used)

# create data frame
mode(used) = "numeric"
used <- as.data.frame(used)
colnames(used) <- c('slope','ndviCoV','ag','cover20','cover2070','cover70','drains','prop.settlement.250','prop.settlement.1500','gHM')
head(used)

# unstandardized data frame
ssf.ext <- cbind(ssf.df, used)

# scale some covariates before we fit it
ssf.ext <- ssf.ext %>%
  mutate_at(.vars = c('slope', 'ndviCoV'), .funs = scale) %>%
  mutate_at(.vars = c('ag','cover20','cover2070','cover70','drains'), .funs = function(x) if_else(!is.na(x), 1, 0)) %>%
  mutate_at(.vars = c('ag','cover20','cover2070','cover70', 'drains'), .funs = as.factor) %>%
  # create covariates for the cosine of the turning angle and log step length. We will compare step length and log step length in the model
  mutate(cos_ta_ = cos(ta_),
         log_sl_ = log(sl_ + .001)) # add a small value for steps of length 0


# filter out NDVI cov outliers
ssf.ext <- ssf.ext[ssf.ext$ndviCoV < 20,] # removes three major outliers from Marima dataset

#' Our covariates are now extracted. Before model fitting, check the data frame to make sure we did everything 
#' correctly!

summary(ssf.ext)
unique(ssf.ext$subject_name)




# prep data - they do not interact with ag at all
ssf.ext <- filter(ssf.ext, !(subject_year %in% c('Caroline-2014','Tressa-2015'))) # note added all chelsea back in

# filter individuals (>1000 used points)
t <- ssf.ext %>% group_by(subject_year, subject_name, subject_sex, tactic.season) %>% 
  filter(case_ == 'TRUE') %>%
  tally() %>%
  filter(n > 1000) # set min number of points for subject_name or subject_year

ssf.ext<- filter(ssf.ext, subject_year %in% t$subject_year)

##### Add Ag Availability for Homerange #####
## Ag availability by home range
# 1. Calculate mcp homeranges
# 2. Calculate proportion of ag within each homerange polygon
# 3. Attach individual-year ag availability values to the dataset 

df <- ssf.ext %>% ungroup() %>% filter(case_ == TRUE) %>% select(subject_year, x1_, y1_)
sp::coordinates(df) <- ~x1_+y1_
split <- split(df, df$subject_year)
mcp <- lapply(split, function(x) {
  x <- adehabitatHR::mcp(x)
  x <- st_as_sf(x) %>%
    terra::vect()
  return(x)})

# get mean ag in homerange (proportion 1/0)
ag2 <- terra::classify(ag, cbind(NA, 0), right=FALSE)
{tic()
  cores = 6
  ag.ext <- mclapply(mcp, function(x) terra::extract(ag2, x, fun = mean)[,2], mc.cores = cores)
  toc()}

ag.avail <- as.data.frame(do.call(rbind, ag.ext))
ag.avail$subject_year <- rownames(ag.avail)
colnames(ag.avail) <- c('ag.avail', 'subject_year')

# merge results
ssf.ext <- merge(ssf.ext, ag.avail, by = 'subject_year')

# save results for later
#write.csv(ag.avail, './SSF/ag.homerange.IY.datatable_20220312.csv')
#write.csv(ssf.ext, './SSF/ssf.df.allmara.IY_10.csv')

# drop old dataframes
remove(extract)
remove(used)
remove(ssf.sf)
remove(ag.ext)

# load data - if needed
ssf.ext <- as.data.frame(data.table::fread('./SSF/ssf.df.allmara.IY_10.csv'))
ssf.ext$drains <- as.factor(ssf.ext$drains)
ssf.ext$subject_year <- as.factor(ssf.ext$subject_year)
ssf.ext$tactic.season <- as.factor(ssf.ext$tactic.season)
ssf.ext$ag <- as.factor(ssf.ext$ag)
ssf.ext$cover20 <- as.factor(ssf.ext$cover20)
ssf.ext$cover2070 <- as.factor(ssf.ext$cover2070)
ssf.ext$cover70 <- as.factor(ssf.ext$cover70)
ssf.ext$V1 <- NULL

##### Fit SSF Model #####
#TODO: Add model selection code

# m.ssf <- ssf.ext %>% amt::fit_clogit(case_ ~ ag + cover20 + cover2070 + cover70 + slope + ndviCoV +
#                                      sl_ + log_sl_ + cos_ta_ + # movement parameters
#                                      strata(step_id_))
# 
# m.ssf <- survival::clogit(case_ ~ ag + cover20 + cover2070 + cover70 + slope + ndviCoV +
#                             sl_ + log_sl_ + cos_ta_ + strata(step_id_),
#                           data = ssf.ext)
# 
# summary(m.ssf)

##### Fit Individual SSFs #####

## Run in parallel 

# fit model
{tic()
  cores = 6
  m.ind.ssf <- split(ssf.ext, ssf.ext$subject_year) # chose splitting variable (subject_name or subject_year)
  m.ind.ssf <- mclapply(m.ind.ssf, function(x) {
    t <- amt::fit_issf(x, case_ ~ ag + cover20 + cover2070 + cover70 + drains + slope + ndviCoV + scale(prop.settlement.1500) +
                          log_sl_ + cos_ta_ + # movement parameters
                          strata(step_id_)) 
    t <- t$model }, # select only the model output
    mc.cores = cores)
  names(m.ind.ssf) <- unique(ssf.ext$subject_year) # chose splitting variable (subject_name or subject_year)
toc()}

# get table of estimates for each individual
id.est.ssf <- lapply(m.ind.ssf, function(x) 
  tab <- x %>% broom::tidy() %>%
    mutate(
      ymin = estimate - 1.96 * std.error,
      ymax = estimate + 1.96 * std.error
    ))
id.est.ssf <- dplyr::bind_rows(id.est.ssf, .id = "subject_year")

# add other ele metadata (sex, ag tactic, etc.)
t <- ssf.ext %>% group_by(subject_year, subject_name, subject_sex, tactic.season) %>% tally() %>% dplyr::select(-n)
id.est.ssf <- merge(id.est.ssf, t, by = 'subject_year')

##### plot results #####

# coeff estimates for all individuals
tt <- filter(id.est.ssf, subject_name %in% c('Ivy','Lucy', 'Chelsea', 'Alina'))
ggplot(tt, aes(x = as.factor(term), y = estimate, color = tactic.season)) + 
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') + 
  geom_pointrange(aes(ymin = ymin, ymax = ymax),
                  position = position_dodge(width = 0.6)) +
  xlab('covariate') + ggtitle('ssf individual-level estimates') +
  labs(color = 'ag tactic') + 
  coord_flip() + facet_wrap(~subject_name)

# coeff estimates by sex
ggplot(id.est.ssf, aes(x = as.factor(term), y = estimate, color = subject_sex)) +
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') + 
  geom_boxplot() +
  xlab('covariate') + ggtitle('ssf individual-level estimates by sex') +
  labs(color = 'sex') + 
  coord_flip()

# coeff estimates by tactic (aggregate)
ggplot(id.est.ssf, aes(x = as.factor(term), y = estimate, color = factor(tactic.season))) +
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') + 
  geom_boxplot() +
  xlab('covariate') + ggtitle('ssf individual-level estimates by ag tactic') +
  labs(color = 'ag tactic') + 
  coord_flip() 


##### Model Function Response with Ag #####
ag.est <- filter(id.est.ssf, term == 'ag1')
plot(ag.est$ag.avail, ag.est$estimate)
ag.est$ag.avail <- log(ag.est$ag.avail+0.0001)
ag.est$subject_name <- as.factor(ag.est$subject_name)
m.funct <- lme4::lmer(estimate ~ ag.avail + (1|subject_name), data = ag.est)
sjPlot::plot_model(m.funct, type = 'pred', show.data = TRUE, title = '', axis.labels = '', dot.size = 1.5)
